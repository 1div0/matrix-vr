<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Inside the Matrix VR</title>
    <link rel="stylesheet" href="/assets/fonts/plex/plex.css">
    <link rel="stylesheet" href="/assets/fonts/ss-pro/ss-pro.css">
    <style>
        html, body {
            margin: 0px;
            padding: 0px;
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            /* -webkit-font-smoothing: antialiased; */
        }
        #canvas {
            width: 100%;
            height: 100%;
        }
        .overlay {
            width: 100%;
            height: 100%;

            position: absolute;
            top: 0px;
            left: 0px;

            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .overlay .github {
            align-self: flex-end;
            margin: 15px;
            display: flex;
            flex-direction: row;
            font-size: 14px;
            color: #333;
            font-family: 'Source Sans Pro', sans-serif;
        }
        .overlay .github .label {
            margin: auto 10px;
            text-transform: uppercase;
            font-weight: 300;
            border-bottom: 1px solid transparent;
            transition: border 250ms ease-in-out;
        }
        .overlay .github .label:hover {
            border-bottom: 1px solid #333;
            cursor: pointer;
        }
        .overlay h1 {
            margin-top: 20px;
            margin-bottom: 15px;
            font-weight: 100;
            font-size: 60px;
            letter-spacing: 12px;
            text-transform: uppercase;
            font-family: 'IBM Plex Sans', sans-serif;
        }
        @media(max-width: 800px) {
            .overlay h1 {
                font-size: 40px;
                letter-spacing: 8px;
            }
        }
        @media(max-width: 550px) {
            .overlay h1 {
                font-size: 30px;
                letter-spacing: 6px;
            }
        }

        .overlay .tagline {
            color: #333;
            text-transform: uppercase;
            font-weight: 100;
            letter-spacing: 2px;
            margin-bottom: 40px;
            font-family: 'Source Sans Pro', sans-serif;
        }
        .overlay .highlight {
            color: #2ea;
            /* font-style: italic; */
            color: white;
            background: #2ea;
            padding: 3px;
        }

        button {
            border: 1px solid #2ea;
            color: #2ea;
            /* color: white; */
            /* background: #2ea; */
            border-radius: 21px;
            font-size: 16px;
            font-family: 'Source Sans Pro', sans-serif;
            padding: 10px 20px;
            font-weight: 400;
            letter-spacing: -0.03em;
            outline: none;
            transition: all 250ms ease-in-out;
        }
        button:hover {
            color: white;
            background: #2ea;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="overlay">
        <div class="github">
            <div class="label">Source</div>
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentcolor">
                <path d="M12,2C6.48,2,2,6.59,2,12.25c0,4.53,2.87,8.37,6.84,9.73c0.5,0.09,0.68-0.22,0.68-0.49c0-0.24-0.01-0.89-0.01-1.74c-2.78,0.62-3.37-1.37-3.37-1.37c-0.45-1.18-1.11-1.5-1.11-1.5c-0.91-0.64,0.07-0.62,0.07-0.62c1,0.07,1.53,1.06,1.53,1.06c0.89,1.57,2.34,1.11,2.91,0.85c0.09-0.66,0.35-1.11,0.63-1.37c-2.22-0.26-4.56-1.14-4.56-5.07c0-1.12,0.39-2.03,1.03-2.75c-0.1-0.26-0.45-1.3,0.1-2.71c0,0,0.84-0.28,2.75,1.05c0.8-0.23,1.65-0.34,2.5-0.34c0.85,0,1.7,0.12,2.5,0.34c1.91-1.33,2.75-1.05,2.75-1.05c0.55,1.41,0.2,2.45,0.1,2.71c0.64,0.72,1.03,1.63,1.03,2.75c0,3.94-2.34,4.81-4.57,5.06c0.36,0.32,0.68,0.94,0.68,1.9c0,1.37-0.01,2.48-0.01,2.81c0,0.27,0.18,0.59,0.69,0.49c3.97-1.36,6.83-5.2,6.83-9.73C22,6.59,17.52,2,12,2"></path>
            </svg>
        </div>
        <h1>Inside the Matrix <!--<span class="highlight">VR</span>--></h1>
        <div class="tagline">A <span class="highlight">WebVR</span> demo by Radek Pazdera</div>
        <button id="start">ENTER VR</button>
    </div>
    <script type="module">
        import * as THREE from './vendor/three/build/three.module.js';
        import { OrbitControls } from './vendor/three/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from './vendor/three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from './vendor/three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from './vendor/three/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { WEBVR } from './vendor/three/examples/jsm/vr/WebVR.js';

        import { construct } from './src/construct.js';
        import { Particle } from './src/particles.js';
        import { sfx } from './src/sfx.js';

        const canvas = document.querySelector('#canvas');
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        const renderer = new THREE.WebGLRenderer({canvas});
        renderer.physicallyCorrectLights = true;
        renderer.gammaOutput = true;
        renderer.gammaFactor = 2.2;
        renderer.setClearColor(0xcccccc);
        renderer.setPixelRatio(window.devicePixelRatio);

        // renderer.vr.enabled = true;
        // document.body.appendChild( WEBVR.createButton( renderer ) );

        const aspect = canvas.width / canvas.height;
        let fov = 20;
        let cameraPosition = { x: -7.6, y: 1.3, z: -7.6 };

        /* Horizontal display */
        if (aspect < 1) {
            fov = 70;
            cameraPosition.x = -4;
            cameraPosition.y = 1.5;
            cameraPosition.z = -4;
            }
        const near = 0.1;
        const far = 1000;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.up = new THREE.Vector3(0, 1, 0);
        camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
        camera.rotation.y = Math.PI/2;

        window.camera = camera;

        const controls = new OrbitControls(camera, canvas);
        // controls.enableZoom = false;
        // controls.enablePan = false;
        // controls.autoRotate = true;
        controls.target = new THREE.Vector3(0, 0.5, 0);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xffffff );

        const particles = [];

        // const axesHelper = new THREE.AxesHelper( 5 );
        // scene.add( axesHelper );

        const sfxPromise = sfx.load();
        construct.setup().then(() => {
            scene.add(construct.object);
            construct.reflectCamera.update(renderer, scene);
            construct.refractCamera.update(renderer, scene);
        })

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        // composer.addPass(new UnrealBloomPass(
        //     new THREE.Vector2(canvas.width, canvas.height),
        //     1.0,
        //     0.5,
        //     0.3,
        // ));

        function switchScenes() {
            // Trigger some particles
            // addParticle(10, 10, 10, 10);
            sfx.effects.storm.stop();
            sfx.effects.drop.play();
            controls.autoRotate = false;

            setTimeout(() => {
                camera.fov = 70;
                controls.target.set(0.1, 0, 0);
                camera.position.set(0, 0, 0);
                camera.updateProjectionMatrix();

                particles.forEach(p => p.show());
                composer.addPass(new UnrealBloomPass(
                    new THREE.Vector2(canvas.width, canvas.height),
                    1.0,
                    0.5,
                    0.3,
                ));

                sfx.effects.code.setLoop(true);
                sfx.effects.code.play();

                setTimeout(() => {
                    sfx.effects.wobble.setLoop(true);
                    sfx.effects.wobble.play();
                }, 8000);
            }, 1000);

            let t = 0;
            let duration = 2000;
            let steps = 60;
            let tick = duration / steps;
            let y = 0;
            let targetY = -80;

            (function transition() {
                // move down
                const tN = t / duration;
                const eased = tN * (2 - tN);

                construct.object.position.y = (targetY - y) * eased;
                scene.background.setRGB(1 - eased, 1 - eased, 1 - eased);
                // camera.position.x = 

                // fade background to black
                t += tick;
                if (t < duration) {
                    setTimeout(transition, tick);
                } else {
                    scene.remove(construct.object);
                }
            })();
        }

        for (let i = 0; i < 1000; i++) {
            const x = (0.5 + Math.random() * 20) * (Math.random() > 0.5 ? 1 : -1);
            const y = (0.5 + Math.random() * 20) * (Math.random() > 0.5 ? 1 : -1);
            const z = (0.5 + Math.random() * 20) * (Math.random() > 0.5 ? 1 : -1);
            const len = Math.floor(10 + Math.random() * 50);
            const p = new Particle(x, y, z, len);
            scene.add(p.mesh);
            particles.push(p);
        }

        renderer.setAnimationLoop((time) => {
            particles.forEach(p => p.update(time));
            controls.update();
            composer.render();
        });

        // requestAnimationFrame(render);

        window.addEventListener('resize', () => {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            camera.aspect = canvas.width / canvas.height;
            camera.updateProjectionMatrix();
            // renderer.setSize(canvas.width, canvas.height, false);
            composer.setSize(canvas.width, canvas.height);
            renderer.setPixelRatio(window.devicePixelRatio);
        });

        const overlay = document.querySelector('.overlay');
        const startButton = document.querySelector('#start');
        startButton.addEventListener('click', () => {
            overlay.style.display = 'none';

            sfxPromise.then(() => {
                sfx.setupEffects(camera);
                sfx.effects.shriek.play();

                sfx.effects.storm.setLoop(true);
                sfx.effects.storm.setVolume(0.2);
                setTimeout(() => {
                    sfx.effects.storm.play();

                    controls.autoRotate = true;
                    controls.autoRotateSpeed = -1;
                }, 3400);

                setTimeout(switchScenes, 10000);
            });
        });
    </script>
</body>
</html>